#ifndef STEP_SIMULATION_STRATEGY_HPP
#define STEP_SIMULATION_STRATEGY_HPP

#include <memory>
#include <vector>

#include "../Geometry/Domain/domain.hpp"
#include "../Geometry/Domain/subdomain.hpp"
#include "node_callback.hpp"
#include "simulation_observer.hpp"

namespace lattice_boltzmann_method 
{
    /*
        @brief Abstract class that represents a strategy for simulating/calculating the values at the next time step with the Lattice Boltzmann Method (LBM). 

        This class is very general (indeed it is abstract): it can be inherited to implement in another way the Lattice Boltzmann Method
        At its's core, it uses a lattice_boltzmann_method::Domain object to access the nodes that compose the physical domain of the problem and 
        it interacts with each node. 

        Also, some lattice_boltzmann_method::NodeCallback objects might be provided if some action needs to be performed on the node after this class
        interacted with it. 
        The user might expect the class to do so:
            for { auto node : collection_of_nodes } {
                node.DoSomething()
                for { auto node_callback : collection_of_callbacks } {
                    node_callback.HandleNode(node)
                }
            }

        It is an observable class, in particular a SimulationObservable. If a class needs to get the simulation Step generated by this class, 
        it can register to this class. Look at lattice_boltzmann_method::SimulationObservable for more info.

        A concrete implementation of this class might be parallel.
    */
    template<int dim>
    class StepSimulationStrategy : public SimulationObservable {
        public:
            StepSimulationStrategy(Domain<dim> &domain, std::unique_ptr<NodeCallback> node_callback=nullptr) : domain_{domain} {
                node_callbacks_.push_back(std::move(node_callback));
            }
            StepSimulationStrategy(std::vector<std::unique_ptr<NodeCallback>> node_callbacks) {
                node_callbacks_.reserve(node_callbacks.size());
                for ( int i=0; i<node_callbacks.size(); i++ ) {
                    if ( node_callbacks[i]) {
                        node_callbacks_.push_back(std::move(node_callbacks[i]));
                    }
                }
            }

            void AddNodeCallback(std::unique_ptr<NodeCallback> node_callback)  { 
                if ( node_callback ) {
                    node_callbacks_.push_back(std::move(node_callback));
                }
            }

            /*
                @brief setups the objects needed for the simulation.
                Setup is not performed in the constructor, such that it is very light weigth.
            */
            virtual void Setup() = 0;

            /*
                @brief calculates the next step of the simulation, which means it advances by a certain deltaT in the simulation
                It is not constant since it changes the nodes
            */
            virtual void SimulateNextStep()=0;

            /*
                @brief calculates the steps of the simulation until `time` is reached, stepping by a certain deltaT at each iteration
                It is not constant since it changes the nodes
            */
            virtual void SimulateUntil(double time)=0;
        protected:
            std::vector<std::unique_ptr<NodeCallback>> node_callbacks_;
            Domain<dim> &domain_;
    };

    template<int dim>
    class SerialStepSimulationStrategy : public StepSimulationStrategy<dim> {
        public:
            SerialStepSimulationStrategy(Domain<dim> &domain, std::unique_ptr<NodeCallback> node_callback) : StepSimulationStrategy<dim>{domain, std::move(node_callback)} {}
            virtual void Setup() override;
            virtual void SimulateNextStep() override;
            virtual void SimulateUntil(double time) override;

        private:
            Subdomain<dim> subdomain;
    };
}

#include "step_simulation_strategy.cpp"

#endif // STEP_SIMULATION_STRATEGY_HPP
