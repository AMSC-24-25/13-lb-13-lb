#ifndef STEP_SIMULATION_STRATEGY_HPP
#define STEP_SIMULATION_STRATEGY_HPP

#include <memory>
#include <vector>

#include "../Geometry/Domain/domain.hpp"
#include "../Geometry/Domain/subdomain.hpp"
#include "node_callback.hpp"
#include "simulation_observer.hpp"

namespace lattice_boltzmann_method 
{
    /*
        @brief Abstract class that represents a strategy for simulating/calculating the values at the next time step with the Lattice Boltzmann Method (LBM). 

        @tparam dim dimension of the problem (1, 2 or 3)

        This class is very general (indeed it is abstract): it can be inherited to implement in another way the Lattice Boltzmann Method
        At its's core, it uses a lattice_boltzmann_method::Domain object to access the nodes that compose the physical domain of the problem and 
        it interacts with each node. 

        Also, some lattice_boltzmann_method::NodeCallback objects might be provided if some action needs to be performed on the node after this class
        interacted with it. 
        The user might expect the class to do so:
            for { auto node : collection_of_nodes } {
                node.DoSomething()
                for { auto node_callback : collection_of_callbacks } {
                    node_callback.HandleNode(node)
                }
            }

        It is an observable class, in particular a SimulationObservable. If a class needs to get the simulation Step generated by this class, 
        it can register to this class. Look at lattice_boltzmann_method::SimulationObservable for more info.

        A concrete implementation of this class might be parallel.
    */
    template<int dim>
    class StepSimulationStrategy : public SimulationObservable {
        public:
            StepSimulationStrategy(Domain<dim> &domain, 
                                   std::unique_ptr<NodeCallback<dim>> node_callback=nullptr,
                                   double starting_time = 0.0,
                                   double time_step = 0.1) 
                    : domain_{domain}, current_time_{starting_time}, time_step_{time_step} {
                node_callbacks_.push_back(std::move(node_callback));
            }
            StepSimulationStrategy(std::vector<std::unique_ptr<NodeCallback<dim>>> node_callbacks) {
                node_callbacks_.reserve(node_callbacks.size());
                for ( int i=0; i<node_callbacks.size(); i++ ) {
                    if ( node_callbacks[i]) {
                        node_callbacks_.push_back(std::move(node_callbacks[i]));
                    }
                }
            }

            void AddNodeCallback(std::unique_ptr<NodeCallback<dim>> node_callback)  { 
                if ( node_callback ) {
                    node_callbacks_.push_back(std::move(node_callback));
                }
            }

            /*
                @brief setups the objects needed for the simulation.
                Setup is not performed in the constructor, such that it is very light weigth.
            */
            virtual void Setup() = 0;

            /*
                @brief calculates the next step of the simulation, which means it advances by a certain deltaT in the simulation
                It is not constant since it changes the nodes
            */
            virtual void SimulateNextStep()=0;

            /*
                @brief calculates the steps of the simulation until `time` is reached, stepping by a certain deltaT at each iteration
                It is not constant since it changes the nodes
            */
            virtual void SimulateUntil(double time);
        protected:
            std::vector<std::unique_ptr<NodeCallback<dim>>> node_callbacks_;
            Domain<dim> &domain_;
            double current_time_;
            double time_step_;

            inline void RunConstCallbacks(const Node<dim> &node) {
                for ( std::unique_ptr<NodeCallback<dim>> &callback : node_callbacks_ ) {
                    callback->HandleNode(node);
                }
            }

            inline void RunNonConstCallbacks(Node<dim> &node) {
                for ( std::unique_ptr<NodeCallback<dim>> &callback : node_callbacks_ ) {
                    callback->HandleNonConstNode(node);
                }
            }
    };

    /*
        @brief serial implementation of the abstract class lattice_boltzmann_method::StepSimulationStrategy<dim>. Refer to this for a general description.

        The simulation is here implemented serially. User might expect the code to be:
        for { auto node : collection_of_nodes } {
            node.Collide()
            node.Propagate();
            // callbacks ...
        }

        This class is a basic example of implementation, we do not suggest to use it. Use a parallel version instead.

    */
    template<int dim>
    class SerialStepSimulationStrategy : public StepSimulationStrategy<dim> {
        public:
            SerialStepSimulationStrategy(Domain<dim> &domain, 
                                         std::unique_ptr<NodeCallback<dim>> node_callback,
                                         double starting_time = 0.0,
                                         double time_step     = 0.1) 
                : StepSimulationStrategy<dim>{domain, std::move(node_callback), starting_time, time_step} {}
            virtual void Setup() override;
            virtual void SimulateNextStep() override;

        private:
            std::shared_ptr<Subdomain<dim>> subdomain_;
    };

}

#include "step_simulation_strategy.cpp"

#endif // STEP_SIMULATION_STRATEGY_HPP
